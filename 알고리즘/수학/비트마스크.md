## 비트 마스크
  <aside>
    이 피자집에는 0부터 19까지의 번호를 갖는 스무 가지의 토핑이 있으며, 주문시 토핑을 넣기 / 넣지 않기를 선택할 수 있다.
  </aside>
  
  ##### 1. 공집합과 꽉 찬 집합 구하기
    int fullPizza = (1 << 20) - 1; 
    ⇒ 1 << 20은 이진수로 1 뒤에 20개의 0이 있는 정수인데, 여기서 1을 빼면 20개의 비트가 모두 킨다. 
    
  ##### 2. 원소 추가  
    페페로니의 번호가 p(0 ≤ p < 20)일 때, 집합 toppings에 페페로니 추가하기
    toppings |= (1 << p);  
    ⇒ 1을 왼쪽으로 p비트 시프트하면 p번 비트만 켜진 정수가 되므로 이 값과 toppings를 비트별 OR하면 
      해당 비트는 반드시 켜지게 된다(toppings에 이미 페페로니가 들어가 있을 경우, 값이 변하지 않음)
    
  ##### 3. 원소의 포함 여부 확인
    토핑 목록에 페페로니가 잘 추가 되었는지 확인하기
    if(toppings & (1 << p))
    ⇒ & 연산의 결과값이  0 또는 1 << p라는 것에 주의하자!!
    
  ##### 4. 원소의 삭제
    토핑 목록에서 페페로니를 삭제하기
    toppings &= ~(1 << p);  
    ⇒ ~(1<<p)는 해당 비트만 꺼지고 나머지는 다 켜진 숫자가 된다. 
      이 숫자와 비트별 AND 연산을 수행하면 toppings의 나머지 비트는 유지되고, p번 비트만 항상 꺼지게 된다.
    
  ##### 5. 원소의 토글  
    p번 토핑이 들어가 있는 경우 빼고, 빠져 있는 경우 넣기
    toppings ^= (1 << p);
    
  ##### 6. 두 집합에 대해 연산하기
    int added = (a | b); // a와 b의 합집합
    int intersection = (a & b); // a와 b의 교집합
    
  ##### 7. 집합의 크기 구하기
    비트를 순회하면서 켜져 있는 비트의 수 직접 세기
  ```java
  // Java 내장 함수: Integer.bitCount(toppings);
  int bitCount(int x){
    if(x == 0) return 0;
    return x % 2 + bitCount(x / 2);
  }
  ```
    
  ##### 8. 최소 원소 찾기
    - ‘정수의 이진수 표현에서 끝에 붙어 있는 0이 몇 개인가?’의 형태로 지원된다. 
      켜져 있는 최하위 비트 밑의 비트들은 전부 0이므로, 이 연산은 켜져 있는 최하위 비트의 번호를 반환하게 된다.
      Java 내장 함수: Integer.numberOfTrailingZeros(toppings);
    - 최하위 비트의 번호 대신 해당 비트를 직접 구하기
       int firstTopping = (toppings & -toppings);

  ##### 9. 최소 원소 지우기
    최소 원소가 무엇인지는 상관 없이 최소 원소 지우기
    toppings &= (toppings - 1);
    
  ##### 10. 모든 부분 집합 순회하기
  ```java
  /*
   * (subset-1) & pizza: subset-1을 하면 켜져 있던 최하위 비트가 꺼지고, 그 밑의 비트들은 전부 켜진다. 
   * 이 결과와 pizza의 교집합을 구하면 그 중 pizza에 속하지 않는 비트들은 모두 꺼진다.
   * 이 연산을 반복하여 pizza의 모든 부분 집합을 방문할 수 있다(공집합은 방문하지 않음)
   */
  for(int subset = pizza; subset; subset = ((subset-1) & pizza)){
    // subset은 pizza의 부분집합
  }    
  ```
