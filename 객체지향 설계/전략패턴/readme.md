#### 명세서

- **패턴의 이름**: 전략 패턴
- **패턴의 분류**: 행위 패턴
- **패턴의 목적**: This pattern defines a family of algorithms, encapsulates each one, and make them inter-changeable. It lets the algorithm vary independently from clients that use it.
- **패턴의 수준**: component
- **패턴의 적용**
  - 한 행위를 다양하게 수행해야 하는 경우
  - 실행시간까지 객체의 행위 방법을 결정할 수 없는 경우
  - 행위를 수행하는 방법을 쉽게 추가하고 싶은 경우
  - 행위를 추가하면서 코드의 크기를 효과적으로 관리하고 싶은 경우
- **패턴 적용 가능 시나리오**
  - 게임에서 어떤 캐릭터가 다양한 무기를 사용하여 적을 공격할 수 있다.
  - 게임에서 레벨에 따라 특정 유닛이 움직이는 방법이 다르다.
- **패턴의 참여자**
  - 전략 인터페이스(Strategy Interface): 전략 메소드의 골격이 선언되어 있는 인터페이스
  - 전략 클래스(Strategy Class): 전략이 구체적으로 구현되어 있는 클래스(다수 존재)
  - 클라이언트 클래스(Client Class): 전략을 활용하는 클래스
- **패턴의 구조**
  <br/>
  <img src="https://github.com/kiki9484/Note/assets/141905308/623e8c9d-e236-4778-a003-09a71372c496" width="450" height="300"/>
- **참여자간 협력**
  - 클라이언트는 전략 객체를 구현하기 위한 맴버 변수를 가지고 있다.
  - 클라이언트는 전략 객체를 수정하기 위한 수정자 메소드를 가지고 있어야 한다.
  - 클라이언트는 전략 객체를 이용하여 수행하는 행위를 가지고 있어야 한다. 전략은 보통 생성자를 통해 의존관계 주입한다.
- **패턴의 구현**
  - 전략이 간단하고 특정한 곳에서만 사용될 경우 람다 표현식을 활용할 수 있다.
- **패턴의 장단점**
  - 장점
    - 전략을 실행시간에 변경할 수 있다.
    - 여러 종류의 행위를 전략 패턴으로 구현할 경우 이들의 조합으로 객체를 쉽게 구성할 수 있다.
    - 알고리즘 구현에 필요한 복잡한 자료구조를 클라이언트로부터 숨길 수 있다.
  - 단점
    - 행위의 모델링이 쉽지 않다. 
- **패턴의 변형**
  - 전략이 클라이언트의 상태가 필요한 경우
    - 전략을 활용하는 클라이언트의 종류가 여러 개인 경우, 이에 대한 고려가 필요하다.
    - 클라이언트의 상태를 전달하는 방법
      - 방법 1. 클라이언트 자체를 전달한다.
        - 결합성이 높아진다.
        - 다른 종류의 클라이언트에서 전략을 사용하기 어려워질 수 있다.
        - 클라이언트와 전략 객체가 서로 의존하는 형태가 될 수 있다. 둘 다 추상 타입에 의존하도록 구현해야 한다.
      - 방법 2. 필요한 데이터만 전달한다.
        - 여러 전략에서 다른 데이터가 필요하면 처리하기 쉽지 않을 수 있다.
- **관련 패턴**
  - 전략 클래스 객체가 불필요하게 많이 생성되는 것을 피하기 위해 싱글톤으로 구현하는 경우가 많다.
